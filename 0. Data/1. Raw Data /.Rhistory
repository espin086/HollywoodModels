glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, my.stock[[1]])#Typically the response variable is first
mean(glm.pred == my.stock[[1]] ) #this gives the prediction accuracy in %
glm.fit <- glm(my.stock[[1]] ~ ., data = my.stock ,family = binomial)
summary(glm.fit)
coef(glm.fit)
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[1] , names( stocks.clean ) ) ]
###################
#Logistic regresion is the simplest model to interpret
glm.fit <- glm(my.stock[[1]] ~ ., data = my.stock ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit,type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(my.stock))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, my.stock[[1]])#Typically the response variable is first
mean(glm.pred == my.stock[[1]] ) #this gives the prediction accuracy in %
my.stock[[1]]
glm.fit <- glm(my.stock[[1]] ~ ., data = my.stock ,family = binomial)
target <- my.stock[[1]]
glm.fit <- glm(target ~ ., data = my.stock ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit,type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(my.stock))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, my.stock[[1]])#Typically the response variable is first
View(my.stock)
View(my.stock)
target <- tickers[1]
glm.fit <- glm(DIS ~ ., data = my.stock ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit,type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(my.stock))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, my.stock[[1]])#Typically the response variable is first
mean(glm.pred == my.stock[[1]] ) #this gives the prediction accuracy in %
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[1] , names( stocks.clean ) ) ]
###################
#Logistic regresion is the simplest model to interpret
target <- tickers[1]
glm.fit <- glm(DIS ~ ., data = my.stock ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit,type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(my.stock))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, my.stock[[1]])#Typically the response variable is first
mean(glm.pred == my.stock[[1]] ) #this gives the prediction accuracy in %
View(my.stock)
row.names(my.stock)
as.Date(row.names(my.stock))
nrows(my.stock)
?nrows
nrow(my.stock)
training <- my.stock[1:nrow(my.stock) * .7]
my.stock[1:10]
my.stock[1:10,]
training <- my.stock[1:nrow(my.stock) * .7, ]
training <- my.stock[1:nrow(my.stock)*.7, ]
nrow(my.stock)*.7
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing <- my.stock[-training]
testing <- my.stock[-training,]
testing.rows <- length(trainig.rows)
testing.rows
trainig.rows
trainig.rows + 1
testing <- my.stock[trainig.rows + 1 ,nrow(my.stock)]
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows ,nrow(my.stock)]
testing <- my.stock[testing.rows:nrow(my.stock)]
testing <- my.stock[testing.rows:nrow(my.stock),]
target <- tickers[1]
glm.fit <- glm(DIS ~ ., data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit, data = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, testing[[1]])#Typically the response variable is first
## downloads historic prices for all constituents of SP500
library(zoo)
library(tseries)
## read in list of constituents, with company name in first column and
## ticker symbol in second column
#Setting Working Directory
## specify time period
dateStart <- "2012-01-01"
dateEnd <- Sys.Date()
## extract symbols and number of iterations
symbols <- c("DIS", "CMCSA", "TWX", "SNE", "FOXA", "VIAB")
nAss <- length(symbols)
## download data on first stock as zoo object
z <- get.hist.quote(instrument = symbols[1], start = dateStart,
end = dateEnd, quote = "AdjClose",
retclass = "zoo", quiet = T)
## use ticker symbol as column name
dimnames(z)[[2]] <- as.character(symbols[1])
## download remaining assets in for loop
for (i in 2:nAss) {
## display progress by showing the current iteration step
cat("Downloading ", i, " out of ", nAss , "\n")
result <- try(x <- get.hist.quote(instrument = symbols[i],
start = dateStart,
end = dateEnd, quote = "AdjClose",
retclass = "zoo", quiet = T))
if(class(result) == "try-error") {
next
}
else {
dimnames(x)[[2]] <- as.character(symbols[i])
## merge with already downloaded data to get assets on same dates
z <- merge(z, x)
}
}
## save data
stocks <- as.data.frame(z)
setwd("~/Documents/HollywoodModels/0. Data/1. Raw Data ")
write.csv(stocks,"EntertainmentStockPrices.csv")
#Create data in forms of returns
library(zoo)
library(reshape)
library(DataCombine)
library(quantmod)
#renaming stocks dataset to keep original untouched
stocks.clean <- stocks
#Calculating losses and gains
tickers <- names(stocks.clean)
#Creating set of 'up or down indicators
for (i in 1:length(tickers)){
stocks.clean[i] <- Delt(stocks.clean[i], type = "log") #Calculating
stocks.clean[i][stocks.clean[i] > 0] <- 1 #dummy variable for price change
stocks.clean[i][stocks.clean[i] < 0] <- 0 #dummy variable for price change
for (j in 1:7){#looping to lag variable
stocks.clean <- slide(stocks.clean, Var = names(stocks.clean[i]), slideBy = -j)
}
}
#Cleaning names of lags as they cause erros when I run other code.
names(stocks.clean) <- gsub('-', '_', names(stocks.clean))
#keeping only complete cases so modeling will work
stocks.clean <- stocks.clean[complete.cases(stocks.clean),]
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[1] , names( stocks.clean ) ) ]
#Creating testing and training datasets
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows:nrow(my.stock),]
###################
#Logistic regresion is the simplest model to interpret
target <- tickers[1]
glm.fit <- glm(DIS ~ ., data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit, data = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, testing[[1]])#Typically the response variable is first
mean(glm.pred == testing[[1]] ) #this gives the prediction accuracy in %
?predict.glm
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, testing[[1]])#Typically the response variable is first
mean(glm.pred == testing[[1]] ) #this gives the prediction accuracy in %
#Select ticker to analyze
ticker.num <- 2
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[ticker.num] , names( stocks.clean ) ) ]
View(my.stock)
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows:nrow(my.stock),]
###################
#Logistic regresion is the simplest model to interpret
target <- tickers[ticker.num]
glm.fit <- glm(DIS ~ ., data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
## downloads historic prices for all constituents of SP500
library(zoo)
library(tseries)
## read in list of constituents, with company name in first column and
## ticker symbol in second column
#Setting Working Directory
## specify time period
dateStart <- "2012-01-01"
dateEnd <- Sys.Date()
## extract symbols and number of iterations
symbols <- c("DIS", "CMCSA", "TWX", "SNE", "FOXA", "VIAB")
nAss <- length(symbols)
## download data on first stock as zoo object
z <- get.hist.quote(instrument = symbols[1], start = dateStart,
end = dateEnd, quote = "AdjClose",
retclass = "zoo", quiet = T)
## use ticker symbol as column name
dimnames(z)[[2]] <- as.character(symbols[1])
## download remaining assets in for loop
for (i in 2:nAss) {
## display progress by showing the current iteration step
cat("Downloading ", i, " out of ", nAss , "\n")
result <- try(x <- get.hist.quote(instrument = symbols[i],
start = dateStart,
end = dateEnd, quote = "AdjClose",
retclass = "zoo", quiet = T))
if(class(result) == "try-error") {
next
}
else {
dimnames(x)[[2]] <- as.character(symbols[i])
## merge with already downloaded data to get assets on same dates
z <- merge(z, x)
}
}
## save data
stocks <- as.data.frame(z)
setwd("~/Documents/HollywoodModels/0. Data/1. Raw Data ")
write.csv(stocks,"EntertainmentStockPrices.csv")
#Create data in forms of returns
library(zoo)
library(reshape)
library(DataCombine)
library(quantmod)
#renaming stocks dataset to keep original untouched
stocks.clean <- stocks
#Calculating losses and gains
tickers <- names(stocks.clean)
#Creating set of 'up or down indicators
for (i in 1:length(tickers)){
stocks.clean[i] <- Delt(stocks.clean[i], type = "log") #Calculating
stocks.clean[i][stocks.clean[i] > 0] <- 1 #dummy variable for price change
stocks.clean[i][stocks.clean[i] < 0] <- 0 #dummy variable for price change
for (j in 1:7){#looping to lag variable
stocks.clean <- slide(stocks.clean, Var = names(stocks.clean[i]), slideBy = -j)
}
}
#Cleaning names of lags as they cause erros when I run other code.
names(stocks.clean) <- gsub('-', '_', names(stocks.clean))
#keeping only complete cases so modeling will work
stocks.clean <- stocks.clean[complete.cases(stocks.clean),]
#Select ticker to analyze
ticker.num <- 2
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[ticker.num] , names( stocks.clean ) ) ]
#Creating testing and training datasets
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows:nrow(my.stock),]
###################
#Logistic regresion is the simplest model to interpret
target <- tickers[ticker.num]
glm.fit <- glm(DIS ~ ., data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, testing[[1]])#Typically the response variable is first
mean(glm.pred == testing[[1]] ) #this gives the prediction accuracy in %
target
target[[1]]
glm.fit <- glm(target ~ ., data = training ,family = binomial)
str(target)
target <- my.stock[[1]]
glm.fit <- glm(target ~ ., data = training ,family = binomial)
target <- training[[1]]
glm.fit <- glm(target ~ ., data = training ,family = binomial)
glm.fit <- glm(CMCSA ~ ., data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, testing[[1]])#Typically the response variable is first
mean(glm.pred == testing[[1]] ) #this gives the prediction accuracy in %
as.formula(paste("y~",paste(listoffactors,collapse="+")))
as.formula(paste("y~",.,collapse="+")))
as.formula(paste("y~",.,collapse="+"))
as.formula(paste("y~",".",collapse="+"))
as.formula(paste("y~","~.",collapse="+"))
as.formula(paste(tickers[ticker.num],"~.",collapse="+"))
#Select ticker to analyze
ticker.num <- 2
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[ticker.num] , names( stocks.clean ) ) ]
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows:nrow(my.stock),]
###################
#Logistic regresion is the simplest model to interpret
target <- training[[1]]
glm.fit <- glm(as.formula(paste(tickers[ticker.num],"~.",collapse="+")), data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
hist(glm.probs) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
table(glm.pred, testing[[1]])#Typically the response variable is first
mean(glm.pred == testing[[1]] ) #this gives the prediction accuracy in %
print(table(glm.pred, testing[[1]]))#Typically the response variable is first
## downloads historic prices for all constituents of SP500
library(zoo)
library(tseries)
## read in list of constituents, with company name in first column and
## ticker symbol in second column
#Setting Working Directory
## specify time period
dateStart <- "2012-01-01"
dateEnd <- Sys.Date()
## extract symbols and number of iterations
symbols <- c("DIS", "CMCSA", "TWX", "SNE", "FOXA", "VIAB")
nAss <- length(symbols)
## download data on first stock as zoo object
z <- get.hist.quote(instrument = symbols[1], start = dateStart,
end = dateEnd, quote = "AdjClose",
retclass = "zoo", quiet = T)
## use ticker symbol as column name
dimnames(z)[[2]] <- as.character(symbols[1])
## download remaining assets in for loop
for (i in 2:nAss) {
## display progress by showing the current iteration step
cat("Downloading ", i, " out of ", nAss , "\n")
result <- try(x <- get.hist.quote(instrument = symbols[i],
start = dateStart,
end = dateEnd, quote = "AdjClose",
retclass = "zoo", quiet = T))
if(class(result) == "try-error") {
next
}
else {
dimnames(x)[[2]] <- as.character(symbols[i])
## merge with already downloaded data to get assets on same dates
z <- merge(z, x)
}
}
## save data
stocks <- as.data.frame(z)
setwd("~/Documents/HollywoodModels/0. Data/1. Raw Data ")
write.csv(stocks,"EntertainmentStockPrices.csv")
#Create data in forms of returns
library(zoo)
library(reshape)
library(DataCombine)
library(quantmod)
#renaming stocks dataset to keep original untouched
stocks.clean <- stocks
#Calculating losses and gains
tickers <- names(stocks.clean)
#Creating set of 'up or down indicators
for (i in 1:length(tickers)){
stocks.clean[i] <- Delt(stocks.clean[i], type = "log") #Calculating
stocks.clean[i][stocks.clean[i] > 0] <- 1 #dummy variable for price change
stocks.clean[i][stocks.clean[i] < 0] <- 0 #dummy variable for price change
for (j in 1:7){#looping to lag variable
stocks.clean <- slide(stocks.clean, Var = names(stocks.clean[i]), slideBy = -j)
}
}
#Cleaning names of lags as they cause erros when I run other code.
names(stocks.clean) <- gsub('-', '_', names(stocks.clean))
#keeping only complete cases so modeling will work
stocks.clean <- stocks.clean[complete.cases(stocks.clean),]
#Select ticker to analyze
ticker.num <- 2
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[ticker.num] , names( stocks.clean ) ) ]
#Creating testing and training datasets
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows:nrow(my.stock),]
###################
#Logistic regresion is the simplest model to interpret
target <- training[[1]]
glm.fit <- glm(as.formula(paste(tickers[ticker.num],"~.",collapse="+")), data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
print(hist(glm.probs)) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
print(table(glm.pred, testing[[1]]))#Typically the response variable is first
print(mean(glm.pred == testing[[1]])) #this gives the prediction accuracy in %
for(tick in 1:length(tickers)){
print(tickers[i])
}
for(i in 1:length(tickers)){
print(tickers[i])
}
for(i in 1:length(tickers)){
print(ticker.num <- i)
}
#Select ticker to analyze
ticker.num <- 2
for(i in 1:length(tickers)){
ticker.num <- i
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[ticker.num] , names( stocks.clean ) ) ]
#Creating testing and training datasets
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows:nrow(my.stock),]
###################
#Logistic regresion is the simplest model to interpret
target <- training[[1]]
glm.fit <- glm(as.formula(paste(tickers[ticker.num],"~.",collapse="+")), data = training ,family = binomial)
summary(glm.fit)
coef(glm.fit)
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
print(hist(glm.probs)) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
print(table(glm.pred, testing[[1]]))#Typically the response variable is first
print(mean(glm.pred == testing[[1]])) #this gives the prediction accuracy in %
}
#Select ticker to analyze
ticker.num <- 2
for(i in 1:length(tickers)){
ticker.num <- i #you can take this entire set of code out of the loop and manually enter #
#Creating a filter so modeling is simplified
my.stock <- stocks.clean[ , grepl( tickers[ticker.num] , names( stocks.clean ) ) ]
#Creating testing and training datasets
trainig.rows <- nrow(my.stock)*.7
training <- my.stock[1:trainig.rows, ]
testing.rows <- trainig.rows + 1
testing <- my.stock[testing.rows:nrow(my.stock),]
###################
#Logistic regresion is the simplest model to interpret
target <- training[[1]]
glm.fit <- glm(as.formula(paste(tickers[ticker.num],"~.",collapse="+")), data = training ,family = binomial)
glm.probs = predict(glm.fit, newdata = testing, type="response") #this code will predict on the training data, response outputs the probability
glm.probs[1:10]
print(hist(glm.probs)) #probablity that a given stock will go up
#turning the probability of up or down into 1 for up and 0 for down
glm.pred = rep(0, nrow(testing))
glm.pred[glm.probs >.5] = 1
##########################
#Result of logistic regression
print(table(glm.pred, testing[[1]]))#Typically the response variable is first
print(mean(glm.pred == testing[[1]])) #this gives the prediction accuracy in %
}
